"use client"

import { useState, useCallback, useEffect, useRef } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
import { Label } from "@/components/ui/label"
import { Card, CardContent } from "@/components/ui/card"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Switch } from "@/components/ui/switch"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"
import {
  ArrowLeft,
  Download,
  ChevronLeft,
  ChevronRight,
  Palette,
  Layout,
  FileText,
  Check,
  Loader2,
  Sparkles,
  ImageIcon,
  Trash2,
  Shuffle,
  Images,
  AlignLeft,
  Save,
  Cloud,
  Plus,
  Minus,
  Settings,
  User,
  Send,
  PanelLeftClose,
  PanelLeft,
  Type,
  FileImage,
  FolderArchive,
  Move,
  Maximize,
  RotateCw,
  Upload,
  Film,
} from "lucide-react"
import { Slider } from "@/components/ui/slider"
import { SlidePreview } from "@/components/slide-preview"
import { ThemePicker } from "@/components/theme-picker"
import { TemplatePicker } from "./template-picker"
import { LayoutPicker } from "@/components/layout-picker"
import type { CarouselData, CarouselSlide, Project, Theme, BrandKit, LayoutType, CustomText } from "@/lib/types"
import type { CarouselTemplate } from "@/lib/templates"
import { DEFAULT_THEMES, LAYOUT_OPTIONS, assignSlideLayouts } from "@/lib/types"
import { TextStyleEditor } from "./text-style-editor"

interface CarouselEditorProps {
  initialData: CarouselData
  projectId?: string | null
  onBack: () => void
}

export function CarouselEditor({ initialData, projectId: initialProjectId, onBack }: CarouselEditorProps) {
  const [slides, setSlides] = useState<CarouselSlide[]>(initialData.slides)
  const [currentSlide, setCurrentSlide] = useState(0)
  const [theme, setTheme] = useState<Theme>(initialData.theme || DEFAULT_THEMES[0])
  const [isAdapting, setIsAdapting] = useState(false)
  const [isGeneratingAllImages, setIsGeneratingAllImages] = useState(false)

  // Sidebar state
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false)
  const [aiPrompt, setAiPrompt] = useState("")
  const [titleEnabled, setTitleEnabled] = useState(true)
  const [descriptionEnabled, setDescriptionEnabled] = useState(true)
  const [brandLogoEnabled, setBrandLogoEnabled] = useState(true)
  const [showBranding, setShowBranding] = useState(true)

  // Design tab section toggles
  const [themeExpanded, setThemeExpanded] = useState(true)
  const [slideImagesExpanded, setSlideImagesExpanded] = useState(true)
  const [layoutExpanded, setLayoutExpanded] = useState(true)
  // Branding state - initialize from initialData if available
  const [brandName, setBrandName] = useState(initialData.brandName || "Your Name")
  const [brandHandle, setBrandHandle] = useState(initialData.brandHandle || "@your_linkedin_handle")
  const [brandImage, setBrandImage] = useState<string | null>(initialData.brandImage || null)
  const [hostImage, setHostImage] = useState<string | null>(initialData.hostImage || null)
  const [guestImage, setGuestImage] = useState<string | null>(initialData.guestImage || null)

  const hasAutoGeneratedRef = useRef(false)
  const slidePreviewRef = useRef<HTMLDivElement>(null)

  // Download state
  const [isDownloading, setIsDownloading] = useState(false)
  const [isUploadingImage, setIsUploadingImage] = useState(false)
  const [isEnhancingImage, setIsEnhancingImage] = useState(false)
  const fileInputRef = useRef<HTMLInputElement>(null)
  const [isExporting, setIsExporting] = useState(false)


  // Template State
  const [templateId, setTemplateId] = useState<string | null>(initialData.templateId || null)

  // Auto-save state
  const [projectId, setProjectId] = useState<string | null>(initialProjectId || null)
  const [isSaving, setIsSaving] = useState(false)
  const [lastSaved, setLastSaved] = useState<Date | null>(null)
  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null)

  // Save project function
  const saveProject = useCallback(async () => {
    setIsSaving(true)
    try {
      const response = await fetch("/api/projects", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          id: projectId,
          topic: initialData.topic,
          slides,
          theme,
          brandName,
          brandHandle,
          brandImage,
          templateId,
        }),
      })

      if (response.ok) {
        const data = await response.json()
        if (!projectId && data.project?.id) {
          setProjectId(data.project.id)
        }
        setLastSaved(new Date())
      }
    } catch (error) {
      console.error("Failed to save project:", error)
    } finally {
      setIsSaving(false)
    }
  }, [projectId, initialData.topic, slides, theme, brandName, brandHandle, brandImage, templateId])

  // Debounced auto-save
  useEffect(() => {
    // Clear existing timeout
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current)
    }

    // Set new timeout for auto-save (2 seconds after last change)
    saveTimeoutRef.current = setTimeout(() => {
      saveProject()
    }, 2000)

    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current)
      }
    }
  }, [slides, theme, brandName, brandHandle, brandImage, templateId, saveProject])

  const updateSlide = useCallback((index: number, updates: Partial<CarouselSlide>) => {
    setSlides((prev) => prev.map((slide, i) => (i === index ? { ...slide, ...updates } : slide)))
  }, [])

  const goToSlide = (index: number) => {
    setCurrentSlide(Math.max(0, Math.min(index, slides.length - 1)))
  }

  const generateBackgroundImage = async (slideIndex: number) => {
    const slide = slides[slideIndex]

    // Note: Previously blocked AI regeneration for extracted video frames
    // Removed per user request - regeneration now allowed for all slides

    updateSlide(slideIndex, { isGeneratingImage: true })

    // Console logging for tracking
    console.log(`\n========== IMAGE REGENERATION START ==========`)
    console.log(`ðŸ“¸ Regenerating image ${slideIndex + 1}/${slides.length}`)
    console.log(`ðŸ“ Topic: ${initialData.topic}`)
    console.log(`ðŸ“Œ Slide Heading: ${slide.heading}`)
    console.log(`ðŸ–¼ï¸ Suggested Image: ${slide.suggested_image}`)
    console.log(`ðŸŽ¨ Has Background: ${!!slide.backgroundImageUrl}`)
    console.log(`â° Started at: ${new Date().toLocaleTimeString()}`)
    console.log(`============================================\n`)

    try {
      // Check if this is an extracted video frame that needs face preservation
      const isVideoFrame = (slide as any).extractedFrame || (slide as any).validatedFrame || slide.backgroundImageUrl?.includes('/frames/')

      // For VIDEO FRAMES: Skip AI editing entirely to preserve the ORIGINAL face
      // AI models CANNOT perfectly preserve faces - they always alter them slightly
      if (isVideoFrame && slide.backgroundImageUrl) {
        console.log(`ðŸŽ­ VIDEO FRAME DETECTED - Preserving ORIGINAL face without ANY AI modification`)
        console.log(`ðŸ’¡ Keeping the authentic video frame to maintain 100% real appearance`)
        updateSlide(slideIndex, { isGeneratingImage: false })
        alert("Original video frame preserved! AI regeneration is skipped to keep the person's face 100% authentic and real.")
        return
      }

      // If there's an existing background image (non-video), use editing API to apply prompt to it
      if (slide.backgroundImageUrl) {
        console.log(`âœ¨ Using EDIT mode - applying prompt to existing background image`)

        const response = await fetch("/api/enhance-image", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            imageUrl: slide.backgroundImageUrl,
            enhancementType: "custom",
            customPrompt: slide.suggested_image,
            slideId: slide.id,
          }),
        })

        if (!response.ok) {
          const error = await response.json()
          throw new Error(error.error || "Failed to apply prompt to image")
        }

        const data = await response.json()
        console.log(`âœ… Image ${slideIndex + 1}/${slides.length} regenerated successfully!`)
        console.log(`ðŸ”— Image URL: ${data.imageUrl}`)
        console.log(`â° Completed at: ${new Date().toLocaleTimeString()}\n`)

        updateSlide(slideIndex, {
          backgroundImageUrl: data.imageUrl,
          isGeneratingImage: false,
        })
      } else {
        // No background - generate from scratch using the original API
        console.log(`ðŸ†• Using GENERATE mode - creating new image from scratch`)

        const response = await fetch("/api/generate-image", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            topic: initialData.topic,
            slideHeading: slide.heading,
            suggestedImage: slide.suggested_image,
            slideIndex: slideIndex,
            entityFocus: slide.entityFocus || "none",
            hostImage,
            guestImage,
          }),
        })

        if (!response.ok) {
          const error = await response.json()
          throw new Error(error.error || "Failed to generate image")
        }

        const data = await response.json()
        console.log(`âœ… Image ${slideIndex + 1}/${slides.length} generated successfully!`)
        console.log(`ðŸ”— Image URL: ${data.imageUrl}`)
        console.log(`â° Completed at: ${new Date().toLocaleTimeString()}\n`)

        updateSlide(slideIndex, {
          backgroundImageUrl: data.imageUrl,
          // Don't update suggested_image - keep the original prompt to avoid duplication
          isGeneratingImage: false,
        })
      }
    } catch (error) {
      console.error(`âŒ Failed to regenerate image ${slideIndex + 1}/${slides.length}:`, error)
      updateSlide(slideIndex, { isGeneratingImage: false })
      alert(error instanceof Error ? error.message : "Failed to regenerate image")
    }
  }

  const generateAllImages = async () => {
    setIsGeneratingAllImages(true)

    // Console logging for tracking batch generation
    console.log(`\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—`)
    console.log(`â•‘     BATCH IMAGE GENERATION START             â•‘`)
    console.log(`â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£`)
    console.log(`â•‘ ðŸ“ Topic: ${initialData.topic.substring(0, 35).padEnd(35)}â•‘`)
    console.log(`â•‘ ðŸ“Š Total Slides: ${slides.length.toString().padEnd(28)}â•‘`)
    console.log(`â•‘ â° Started: ${new Date().toLocaleTimeString().padEnd(29)}â•‘`)
    console.log(`â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n`)

    // Mark all slides as generating
    setSlides((prev) => prev.map((slide) => ({ ...slide, isGeneratingImage: true })))

    try {
      // Generate images for all slides in parallel
      const promises = slides.map(async (slide, index) => {
        // âœ… SKIP AI GENERATION if slide already has an extracted video frame
        // This preserves the REAL face from the video instead of generating AI faces
        if ((slide as any).extractedFrame || (slide as any).validatedFrame || slide.backgroundImageUrl?.includes('/frames/')) {
          console.log(`â­ï¸ Skipping AI for slide ${index + 1} - preserving REAL face from video`)
          // Return success with existing image so it's not overwritten
          return { index, imageUrl: slide.backgroundImageUrl, generatedPrompt: slide.suggested_image, success: true }
        }

        // All images go through the generate-image API for professional regeneration
        console.log(`ðŸš€ Starting image ${index + 1}/${slides.length}: "${slide.heading}"`)

        try {
          const response = await fetch("/api/generate-image", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              topic: initialData.topic,
              slideHeading: slide.heading,
              suggestedImage: slide.suggested_image,
              slideIndex: index,
              entityFocus: slide.entityFocus || "none",
              hostImage,
              guestImage,
            }),
          })

          if (!response.ok) {
            const error = await response.json()
            throw new Error(error.error || "Failed to generate image")
          }

          const data = await response.json()
          console.log(`âœ… Image ${index + 1}/${slides.length} DONE â†’ ${data.imageUrl}`)
          return { index, imageUrl: data.imageUrl, generatedPrompt: data.generatedPrompt, success: true }
        } catch (error) {
          console.error(`âŒ Image ${index + 1}/${slides.length} FAILED:`, error)
          return { index, success: false }
        }
      })

      const results = await Promise.all(promises)

      // Summary logging
      const successCount = results.filter(r => r.success).length
      const failCount = results.filter(r => !r.success).length
      console.log(`\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—`)
      console.log(`â•‘     BATCH IMAGE GENERATION COMPLETE          â•‘`)
      console.log(`â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£`)
      console.log(`â•‘ âœ… Successful: ${successCount.toString().padEnd(30)}â•‘`)
      console.log(`â•‘ âŒ Failed: ${failCount.toString().padEnd(34)}â•‘`)
      console.log(`â•‘ â° Completed: ${new Date().toLocaleTimeString().padEnd(27)}â•‘`)
      console.log(`â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n`)

      // Update all slides with results
      setSlides((prev) => prev.map((slide, index) => {
        const result = results.find((r) => r.index === index)
        return {
          ...slide,
          isGeneratingImage: false,
          backgroundImageUrl: result?.success ? result.imageUrl : slide.backgroundImageUrl,
          suggested_image: result?.success && result.generatedPrompt ? result.generatedPrompt : slide.suggested_image,
        }
      }))
    } catch (error) {
      console.error("âŒ Batch generation failed:", error)
      setSlides((prev) => prev.map((slide) => ({ ...slide, isGeneratingImage: false })))
    } finally {
      setIsGeneratingAllImages(false)
    }
  }

  useEffect(() => {
    if (!hasAutoGeneratedRef.current) {
      hasAutoGeneratedRef.current = true

      // Check if any slide already has a saved image (from database)
      // If images are local paths (start with /uploads/), don't regenerate
      const hasExistingImages = slides.some(
        (slide) => slide.backgroundImageUrl?.startsWith("/uploads/") ||
          slide.backgroundImageUrl?.includes("/frames/") ||
          (slide as any).extractedFrame
      )

      if (!hasExistingImages) {
        generateAllImages()
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  const removeBackgroundImage = (slideIndex: number) => {
    updateSlide(slideIndex, { backgroundImageUrl: undefined })
  }

  // Upload background image manually
  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    setIsUploadingImage(true)
    try {
      const formData = new FormData()
      formData.append("file", file)

      const response = await fetch("/api/upload-image", {
        method: "POST",
        body: formData,
      })

      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error || "Failed to upload image")
      }

      const data = await response.json()
      updateSlide(currentSlide, {
        backgroundImageUrl: data.imageUrl,
        backgroundImagePosition: { x: 50, y: 50 },
        backgroundImageScale: 100,
        backgroundImageRotation: 0,
      })
    } catch (error) {
      console.error("Failed to upload image:", error)
      alert(error instanceof Error ? error.message : "Failed to upload image")
    } finally {
      setIsUploadingImage(false)
      // Reset the input so the same file can be selected again
      if (fileInputRef.current) {
        fileInputRef.current.value = ""
      }
    }
  }

  // Enhance background image using OpenAI
  const enhanceBackgroundImage = async (slideIndex: number) => {
    const slide = slides[slideIndex]

    if (!slide.backgroundImageUrl) {
      alert("No background image to enhance")
      return
    }

    setIsEnhancingImage(true)
    updateSlide(slideIndex, { isGeneratingImage: true })

    console.log(`\n========== IMAGE ENHANCEMENT START ==========`)
    console.log(`âœ¨ Enhancing image for slide ${slideIndex + 1}/${slides.length}`)
    console.log(`ðŸ–¼ï¸ Current Image: ${slide.backgroundImageUrl}`)
    console.log(`â° Started at: ${new Date().toLocaleTimeString()}`)
    console.log(`============================================\n`)

    try {
      const response = await fetch("/api/enhance-image", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          imageUrl: slide.backgroundImageUrl,
          enhancementType: "quality",
          slideId: slide.id,
        }),
      })

      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error || "Failed to enhance image")
      }

      const data = await response.json()
      console.log(`âœ… Image ${slideIndex + 1}/${slides.length} enhanced successfully!`)
      console.log(`ðŸ”— Enhanced Image URL: ${data.imageUrl}`)
      console.log(`â° Completed at: ${new Date().toLocaleTimeString()}\n`)

      updateSlide(slideIndex, {
        backgroundImageUrl: data.imageUrl,
        isGeneratingImage: false,
      })
    } catch (error) {
      console.error(`âŒ Failed to enhance image ${slideIndex + 1}/${slides.length}:`, error)
      updateSlide(slideIndex, { isGeneratingImage: false })
      alert(error instanceof Error ? error.message : "Failed to enhance image")
    } finally {
      setIsEnhancingImage(false)
    }
  }

  const toggleDescriptionLength = () => {
    updateSlide(currentSlide, {
      useExtendedDescription: !slides[currentSlide].useExtendedDescription
    })
  }

  const handleSlideLayoutChange = async (newLayout: LayoutType) => {
    const currentSlideData = slides[currentSlide]
    const previousLayout = currentSlideData.layout || "centered"

    const prevConfig = LAYOUT_OPTIONS.find((l) => l.id === previousLayout)
    const newConfig = LAYOUT_OPTIONS.find((l) => l.id === newLayout)

    // Auto-switch Short/Long description based on layout's content size
    // Diagonal Split and Circle Frame use short description by default
    const shortDescLayouts = ["diagonal-split", "circle-frame"]
    const useShortDesc = shortDescLayouts.includes(newLayout)

    // Update layout and description toggle immediately
    updateSlide(currentSlide, {
      layout: newLayout,
      useShortDescription: useShortDesc,
      useExtendedDescription: true
    })

    // If content size changed, adapt content for this slide
    if (prevConfig?.contentSize !== newConfig?.contentSize) {
      setIsAdapting(true)
      try {
        const response = await fetch("/api/adapt-content", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            slides: [currentSlideData],
            layout: newLayout,
            topic: initialData.topic,
          }),
        })

        if (response.ok) {
          const data = await response.json()
          if (data.slides && data.slides[0]) {
            updateSlide(currentSlide, {
              ...data.slides[0],
              layout: newLayout,
              useShortDescription: useShortDesc,
              useExtendedDescription: true,
              backgroundImageUrl: currentSlideData.backgroundImageUrl,
            })
          }
        }
      } catch (error) {
        console.error("Failed to adapt content:", error)
      } finally {
        setIsAdapting(false)
      }
    }
  }

  const shuffleAllLayouts = () => {
    setSlides(assignSlideLayouts(slides, true))
  }

  const addSlide = () => {
    const newSlide: CarouselSlide = {
      id: `slide-${Date.now()}`,
      heading: "New Slide",
      body: "Add your content here...",
      bodyShort: "Add content...",
      bodyLong: "Add your detailed content here. This space is perfect for longer descriptions and explanations.",
      suggested_image: "A professional, modern image related to your topic",
      tone: "educational",
      min_text_version: "",
      max_text_version: "",
      layout: "centered",
      useExtendedDescription: false,
      backgroundImagePosition: { x: 50, y: 50 },
      backgroundImageScale: 100,
      backgroundImageRotation: 0,
    }

    // Insert after current slide
    const newSlides = [...slides]
    newSlides.splice(currentSlide + 1, 0, newSlide)
    setSlides(newSlides)
    setCurrentSlide(currentSlide + 1)
  }

  const deleteSlide = () => {
    if (slides.length <= 1) {
      alert("Cannot delete the last slide")
      return
    }

    const newSlides = slides.filter((_, index) => index !== currentSlide)
    setSlides(newSlides)

    // Adjust current slide index if needed
    if (currentSlide >= newSlides.length) {
      setCurrentSlide(newSlides.length - 1)
    }
  }

  // Download current slide as PNG
  const downloadCurrentSlide = async () => {
    if (!slidePreviewRef.current) return

    setIsDownloading(true)
    try {
      const { toPng } = await import('html-to-image')

      const dataUrl = await toPng(slidePreviewRef.current, {
        cacheBust: true,
        pixelRatio: 4, // High resolution
        backgroundColor: theme.backgroundColor,
        skipFonts: true, // Prevent CORS errors with Google Fonts
        style: {
          transform: 'scale(1)', // Ensure no unintended transforms
        },
        filter: (node) => {
          // Filter out incompatible stylesheets if needed, but html-to-image handles them better
          return true
        }
      })

      const link = document.createElement('a')
      link.download = `slide_${currentSlide + 1}.png`
      link.href = dataUrl
      link.click()
    } catch (error) {
      console.error('Failed to download slide:', error)
    } finally {
      setIsDownloading(false)
    }
  }

  // Download all slides as individual images
  const downloadAllSlides = async () => {
    setIsDownloading(true)
    setIsExporting(true) // Render all slides in background

    try {
      // Give React time to render all slides
      await new Promise(resolve => setTimeout(resolve, 2000))

      const { toPng } = await import('html-to-image')
      const JSZip = (await import('jszip')).default
      const zip = new JSZip()

      // Capture each slide from the hidden export container
      for (let i = 0; i < slides.length; i++) {
        // Small delay between processing
        await new Promise(resolve => setTimeout(resolve, 500))

        const slideElement = document.getElementById(`slide-export-${i}`)

        if (slideElement) {
          try {
            const dataUrl = await toPng(slideElement, {
              cacheBust: true,
              pixelRatio: 4, // High resolution
              backgroundColor: theme.backgroundColor,
              width: 400, // Explicit width matches the container
              style: {
                transform: 'scale(1)',
              }
            })

            const base64Data = dataUrl.split(',')[1]
            zip.file(`slide_${i + 1}.png`, base64Data, { base64: true })

          } catch (slideError) {
            console.error(`Error capturing slide ${i + 1}:`, slideError)
            zip.file(`error_slide_${i + 1}.txt`, `Failed to capture: ${String(slideError)}`)
          }
        }
      }

      const content = await zip.generateAsync({ type: 'blob' })
      const link = document.createElement('a')
      link.download = `${initialData.topic.toLowerCase().replace(/\s+/g, '-')}_slides.zip`
      link.href = URL.createObjectURL(content)
      link.click()
      URL.revokeObjectURL(link.href)

    } catch (error) {
      console.error('Failed to download slides:', error)
    } finally {
      setIsDownloading(false)
      setIsExporting(false)
    }
  }

  const currentSlideData = slides[currentSlide]

  if (!currentSlideData) {
    return (
      <div className="h-screen flex items-center justify-center bg-muted/30">
        <div className="text-center">
          <h2 className="text-xl font-semibold mb-2">No slides found</h2>
          <Button onClick={onBack}>Go Back</Button>
        </div>
      </div>
    )
  }

  const currentLayout = currentSlideData.layout || "centered"

  return (
    <div className="h-screen bg-muted/30 flex overflow-hidden w-full">
      {/* Left Sidebar */}
      <div
        className={`bg-background border-r transition-all duration-300 flex flex-col h-full ${sidebarCollapsed ? 'w-0 overflow-hidden' : 'w-[360px]'
          }`}
      >
        {/* Sidebar Content */}
        <div className="flex-1 flex flex-col min-h-0">
          <Tabs defaultValue="design" className="flex-1 flex flex-col min-h-0">
            {/* Tab Navigation */}
            <div className="p-4 pb-0">
              <TabsList className="w-full bg-muted/50 p-1 rounded-full">
                <TabsTrigger
                  value="design"
                  className="flex-1 rounded-full data-[state=active]:bg-background data-[state=active]:shadow-sm"
                >
                  <Palette className="h-4 w-4 mr-2" />
                  Design
                </TabsTrigger>
                <TabsTrigger
                  value="content"
                  className="flex-1 rounded-full data-[state=active]:bg-background data-[state=active]:shadow-sm"
                >
                  <FileText className="h-4 w-4 mr-2" />
                  Content
                </TabsTrigger>
                <TabsTrigger
                  value="brand"
                  className="flex-1 rounded-full data-[state=active]:bg-background data-[state=active]:shadow-sm"
                >
                  <User className="h-4 w-4 mr-2" />
                  Brand
                </TabsTrigger>
              </TabsList>
            </div>

            {/* Scrollable Content Area */}
            <div className="flex-1 overflow-y-auto min-h-0">
              <div className="p-4 space-y-4">
                <TabsContent value="content" className="mt-0 space-y-4 m-0">
                  {/* Content Edit Section */}
                  <Card className="shadow-sm">
                    <CardContent className="p-4 space-y-4">
                      <h3 className="text-sm font-semibold text-primary">Content Edit</h3>

                      {/* Title Toggle */}
                      <div className="space-y-3">
                        <div className="flex items-center justify-between">
                          <Label htmlFor="title-toggle" className="font-medium">Title</Label>
                          <Switch
                            id="title-toggle"
                            checked={titleEnabled}
                            onCheckedChange={setTitleEnabled}
                          />
                        </div>
                        {titleEnabled && (
                          <div className="space-y-2">
                            <Input
                              value={currentSlideData.heading}
                              onChange={(e) => updateSlide(currentSlide, { heading: e.target.value })}
                              className="bg-muted/30"
                            />
                            <TextStyleEditor
                              label="Title"
                              style={currentSlideData.headingStyle}
                              onChange={(newStyle) => updateSlide(currentSlide, { headingStyle: newStyle })}
                            />
                          </div>
                        )}
                      </div>

                      {/* Description Toggle */}
                      <div className="space-y-3">
                        <div className="flex items-center justify-between">
                          <Label htmlFor="description-toggle" className="font-medium">Description</Label>
                          <Switch
                            id="description-toggle"
                            checked={descriptionEnabled}
                            onCheckedChange={setDescriptionEnabled}
                          />
                        </div>

                        {descriptionEnabled && (
                          <div className="space-y-3">
                            {currentSlideData.useShortDescription ? (
                              <div className="space-y-1.5">
                                <Label htmlFor="bodyShort" className="text-xs text-muted-foreground">Short Version</Label>
                                <Textarea
                                  id="bodyShort"
                                  value={currentSlideData.bodyShort || currentSlideData.body || ""}
                                  onChange={(e) => updateSlide(currentSlide, {
                                    bodyShort: e.target.value,
                                    body: e.target.value,
                                    useExtendedDescription: true
                                  })}
                                  placeholder="Concise version for compact layouts..."
                                  className="bg-muted/30 min-h-[60px] text-sm"
                                />
                              </div>
                            ) : (
                              <div className="space-y-1.5">
                                <Label htmlFor="bodyLong" className="text-xs text-muted-foreground">Long Version</Label>
                                <Textarea
                                  id="bodyLong"
                                  value={currentSlideData.bodyLong || ""}
                                  onChange={(e) => updateSlide(currentSlide, {
                                    bodyLong: e.target.value,
                                    useExtendedDescription: true
                                  })}
                                  placeholder="Detailed version for standard layouts..."
                                  className="bg-muted/30 min-h-[100px] text-sm"
                                />
                              </div>
                            )}

                            <TextStyleEditor
                              label="Description"
                              style={currentSlideData.bodyStyle}
                              onChange={(newStyle) => updateSlide(currentSlide, { bodyStyle: newStyle })}
                            />
                          </div>
                        )}
                      </div>
                    </CardContent>
                  </Card>

                  {/* Custom Text Section */}
                  <Card className="shadow-sm">
                    <CardContent className="p-4 space-y-3">
                      <div className="flex items-center justify-between">
                        <h3 className="text-sm font-semibold text-primary flex items-center gap-2">
                          <Type className="h-4 w-4" />
                          Custom Text
                        </h3>
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => {
                            const newText: CustomText = {
                              id: `text-${Date.now()}`,
                              text: "Your text here",
                              x: 50,
                              y: 50,
                              fontSize: "base",
                              fontWeight: "normal",
                              color: "heading",
                            }
                            updateSlide(currentSlide, {
                              customTexts: [...(currentSlideData.customTexts || []), newText],
                            })
                          }}
                        >
                          <Plus className="h-4 w-4 mr-1" />
                          Add Text
                        </Button>
                      </div>

                      {currentSlideData.customTexts && currentSlideData.customTexts.length > 0 ? (
                        <div className="space-y-3">
                          {currentSlideData.customTexts.map((customText, index) => (
                            <div key={customText.id} className="p-3 bg-muted/30 rounded-lg space-y-3">
                              <div className="flex items-center justify-between">
                                <span className="text-xs font-medium text-muted-foreground">Text {index + 1}</span>
                                <Button
                                  variant="ghost"
                                  size="icon"
                                  className="h-6 w-6 text-destructive"
                                  onClick={() => {
                                    updateSlide(currentSlide, {
                                      customTexts: currentSlideData.customTexts?.filter((t) => t.id !== customText.id),
                                    })
                                  }}
                                >
                                  <Trash2 className="h-3 w-3" />
                                </Button>
                              </div>

                              <Input
                                value={customText.text}
                                onChange={(e) => {
                                  updateSlide(currentSlide, {
                                    customTexts: currentSlideData.customTexts?.map((t) =>
                                      t.id === customText.id ? { ...t, text: e.target.value } : t
                                    ),
                                  })
                                }}
                                placeholder="Enter your text..."
                                className="bg-background text-sm"
                              />

                              <p className="text-xs text-muted-foreground italic">
                                Click on text in preview and use arrow keys to move
                              </p>

                              <div className="grid grid-cols-3 gap-2">
                                <div className="space-y-1">
                                  <Label className="text-xs">Size</Label>
                                  <Select
                                    value={customText.fontSize}
                                    onValueChange={(value: CustomText["fontSize"]) => {
                                      updateSlide(currentSlide, {
                                        customTexts: currentSlideData.customTexts?.map((t) =>
                                          t.id === customText.id ? { ...t, fontSize: value } : t
                                        ),
                                      })
                                    }}
                                  >
                                    <SelectTrigger className="h-8 text-xs">
                                      <SelectValue />
                                    </SelectTrigger>
                                    <SelectContent>
                                      <SelectItem value="sm">Small</SelectItem>
                                      <SelectItem value="base">Normal</SelectItem>
                                      <SelectItem value="lg">Large</SelectItem>
                                      <SelectItem value="xl">XL</SelectItem>
                                      <SelectItem value="2xl">2XL</SelectItem>
                                      <SelectItem value="3xl">3XL</SelectItem>
                                    </SelectContent>
                                  </Select>
                                </div>
                                <div className="space-y-1">
                                  <Label className="text-xs">Weight</Label>
                                  <Select
                                    value={customText.fontWeight}
                                    onValueChange={(value: CustomText["fontWeight"]) => {
                                      updateSlide(currentSlide, {
                                        customTexts: currentSlideData.customTexts?.map((t) =>
                                          t.id === customText.id ? { ...t, fontWeight: value } : t
                                        ),
                                      })
                                    }}
                                  >
                                    <SelectTrigger className="h-8 text-xs">
                                      <SelectValue />
                                    </SelectTrigger>
                                    <SelectContent>
                                      <SelectItem value="normal">Normal</SelectItem>
                                      <SelectItem value="medium">Medium</SelectItem>
                                      <SelectItem value="semibold">Semibold</SelectItem>
                                      <SelectItem value="bold">Bold</SelectItem>
                                      <SelectItem value="black">Black</SelectItem>
                                    </SelectContent>
                                  </Select>
                                </div>
                                <div className="space-y-1">
                                  <Label className="text-xs">Color</Label>
                                  <Select
                                    value={customText.color}
                                    onValueChange={(value: CustomText["color"]) => {
                                      updateSlide(currentSlide, {
                                        customTexts: currentSlideData.customTexts?.map((t) =>
                                          t.id === customText.id ? { ...t, color: value } : t
                                        ),
                                      })
                                    }}
                                  >
                                    <SelectTrigger className="h-8 text-xs">
                                      <SelectValue />
                                    </SelectTrigger>
                                    <SelectContent>
                                      <SelectItem value="heading">Heading</SelectItem>
                                      <SelectItem value="text">Text</SelectItem>
                                      <SelectItem value="accent">Accent</SelectItem>
                                      <SelectItem value="white">White</SelectItem>
                                      <SelectItem value="black">Black</SelectItem>
                                    </SelectContent>
                                  </Select>
                                </div>
                              </div>
                            </div>
                          ))}
                        </div>
                      ) : (
                        <p className="text-xs text-muted-foreground text-center py-2">
                          No custom text added. Click "Add Text" to add custom text to your slide.
                        </p>
                      )}
                    </CardContent>
                  </Card>

                </TabsContent>

                <TabsContent value="design" className="mt-0 space-y-4 m-0">
                  {/* Template Picker Section */}
                  <Card className="shadow-sm">
                    <CardContent className="p-4 space-y-4">
                      <Label className="font-medium">Template</Label>
                      <TemplatePicker
                        selectedTemplateId={templateId}
                        onTemplateSelect={(t) => {
                          setTemplateId(t ? t.id : null)
                          // Update theme colors to match template defaults if user switches
                          if (t) {
                            // Extract colors from template layers or use defaults
                            const headingLayer = t.layers.find(l => l.id === "heading")
                            const bodyLayer = t.layers.find(l => l.id === "body")

                            const newTheme: Theme = {
                              id: "custom",
                              name: t.name + " Theme",
                              backgroundColor: t.backgroundStyle.type === "solid" ? t.backgroundStyle.value : "#ffffff",
                              headingColor: headingLayer?.textStyle?.color || "#000000",
                              textColor: bodyLayer?.textStyle?.color || "#333333",
                              accentColor: "#3b82f6" // Default accent
                            }
                            setTheme(newTheme)
                          }
                        }}
                      />
                    </CardContent>
                  </Card>

                  {/* Theme Section */}
                  <Card className="shadow-sm">
                    <CardContent className="p-4 space-y-4">
                      <div className="flex items-center justify-between">
                        <Label htmlFor="theme-toggle" className="font-medium">Theme</Label>
                        <Switch
                          id="theme-toggle"
                          checked={themeExpanded}
                          onCheckedChange={setThemeExpanded}
                        />
                      </div>
                      {themeExpanded && (
                        <ThemePicker currentTheme={theme} onThemeChange={setTheme} />
                      )}
                    </CardContent>
                  </Card>

                  {/* Slide Images Section */}
                  <Card className="shadow-sm">
                    <CardContent className="p-4 space-y-4">
                      <div className="flex items-center justify-between">
                        <Label htmlFor="slide-images-toggle" className="font-medium">Slide Images</Label>
                        <Switch
                          id="slide-images-toggle"
                          checked={slideImagesExpanded}
                          onCheckedChange={setSlideImagesExpanded}
                        />
                      </div>
                      {slideImagesExpanded && (
                        <>
                          {/* Extracted Video Frame Section */}
                          {(currentSlideData as any).extractedFrame && (
                            <div className="space-y-3 p-3 bg-blue-50 dark:bg-blue-950/20 border border-blue-200 dark:border-blue-800 rounded-lg">
                              <div className="flex items-center justify-between">
                                <Label className="text-sm font-semibold text-blue-700 dark:text-blue-300 flex items-center gap-2">
                                  <Film className="h-4 w-4" />
                                  Video Frame Match
                                </Label>
                                <span className="text-xs text-muted-foreground">
                                  {((currentSlideData as any).extractedFrame.confidence * 100).toFixed(0)}% confidence
                                </span>
                              </div>

                              <div className="relative rounded-md overflow-hidden group">
                                <img
                                  src={(currentSlideData as any).extractedFrame.url}
                                  alt={`Frame at ${(currentSlideData as any).extractedFrame.timestamp}`}
                                  className="w-full h-auto"
                                />
                                <div className="absolute bottom-0 left-0 right-0 bg-black/60 p-2">
                                  <p className="text-white text-xs">
                                    @ {(currentSlideData as any).extractedFrame.timestamp}
                                  </p>
                                </div>
                              </div>

                              {(currentSlideData as any).extractedFrame.reasoning && (
                                <p className="text-xs text-muted-foreground italic">
                                  {(currentSlideData as any).extractedFrame.reasoning}
                                </p>
                              )}

                              <Button
                                variant="default"
                                size="sm"
                                className="w-full"
                                onClick={() => {
                                  updateSlide(currentSlide, {
                                    backgroundImageUrl: (currentSlideData as any).extractedFrame.url
                                  })
                                }}
                              >
                                <Film className="h-4 w-4 mr-2" />
                                Use This Frame
                              </Button>
                            </div>
                          )}

                          <div className="space-y-2">
                            <Label htmlFor="image" className="text-xs text-muted-foreground">Image Generation Prompt</Label>
                            <Textarea
                              id="image"
                              value={currentSlideData.suggested_image}
                              onChange={(e) => updateSlide(currentSlide, { suggested_image: e.target.value })}
                              className="text-sm min-h-[100px] resize-y"
                              placeholder="Describe the image you want to generate..."
                            />
                          </div>
                          {/* Hidden file input for image upload */}
                          <input
                            type="file"
                            ref={fileInputRef}
                            onChange={handleImageUpload}
                            accept="image/*"
                            className="hidden"
                          />
                          <div className="flex flex-col gap-4">
                            {currentSlideData.backgroundImageUrl ? (
                              <>
                                <div className="grid grid-cols-2 gap-2">
                                  <Button
                                    variant="outline"
                                    size="sm"
                                    onClick={() => generateBackgroundImage(currentSlide)}
                                    disabled={currentSlideData.isGeneratingImage || isUploadingImage || isEnhancingImage}
                                  >
                                    {currentSlideData.isGeneratingImage && !isEnhancingImage ? (
                                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                                    ) : (
                                      <ImageIcon className="h-4 w-4 mr-2" />
                                    )}
                                    Regenerate
                                  </Button>
                                  <Button
                                    variant="outline"
                                    size="sm"
                                    onClick={() => enhanceBackgroundImage(currentSlide)}
                                    disabled={currentSlideData.isGeneratingImage || isUploadingImage || isEnhancingImage}
                                  >
                                    {isEnhancingImage ? (
                                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                                    ) : (
                                      <Sparkles className="h-4 w-4 mr-2" />
                                    )}
                                    Enhance
                                  </Button>
                                </div>
                                <div className="flex gap-2">
                                  <Button
                                    variant="outline"
                                    size="sm"
                                    className="flex-1"
                                    onClick={() => fileInputRef.current?.click()}
                                    disabled={currentSlideData.isGeneratingImage || isUploadingImage || isEnhancingImage}
                                  >
                                    {isUploadingImage ? (
                                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                                    ) : (
                                      <Upload className="h-4 w-4 mr-2" />
                                    )}
                                    Upload
                                  </Button>
                                  <Button
                                    variant="outline"
                                    size="sm"
                                    onClick={() => removeBackgroundImage(currentSlide)}
                                    disabled={currentSlideData.isGeneratingImage || isUploadingImage || isEnhancingImage}
                                  >
                                    <Trash2 className="h-4 w-4" />
                                  </Button>
                                </div>

                                {/* Image Manipulation Controls */}
                                <div className="space-y-4 p-3 bg-muted/30 rounded-lg border">
                                  <h4 className="text-xs font-semibold uppercase tracking-wider text-muted-foreground mb-2">
                                    Image Adjustments
                                  </h4>

                                  {/* Position Controls */}
                                  <div className="space-y-3">
                                    <div className="flex items-center justify-between">
                                      <Label className="text-xs flex items-center gap-2">
                                        <Move className="h-3 w-3" /> Position
                                      </Label>
                                      <Button
                                        variant="ghost"
                                        size="sm"
                                        className="h-5 text-[10px] px-2"
                                        onClick={() => updateSlide(currentSlide, { backgroundImagePosition: { x: 50, y: 50 } })}
                                      >
                                        Reset
                                      </Button>
                                    </div>
                                    <div className="space-y-2">
                                      <div className="flex items-center gap-2">
                                        <span className="text-[10px] w-4 text-muted-foreground">X</span>
                                        <Slider
                                          value={[currentSlideData.backgroundImagePosition?.x ?? 50]}
                                          min={0}
                                          max={100}
                                          step={1}
                                          className="flex-1"
                                          onValueChange={(value) => updateSlide(currentSlide, {
                                            backgroundImagePosition: {
                                              ...currentSlideData.backgroundImagePosition ?? { x: 50, y: 50 },
                                              x: value[0]
                                            }
                                          })}
                                        />
                                        <span className="text-[10px] w-6 text-right">{currentSlideData.backgroundImagePosition?.x ?? 50}%</span>
                                      </div>
                                      <div className="flex items-center gap-2">
                                        <span className="text-[10px] w-4 text-muted-foreground">Y</span>
                                        <Slider
                                          value={[currentSlideData.backgroundImagePosition?.y ?? 50]}
                                          min={0}
                                          max={100}
                                          step={1}
                                          className="flex-1"
                                          onValueChange={(value) => updateSlide(currentSlide, {
                                            backgroundImagePosition: {
                                              ...currentSlideData.backgroundImagePosition ?? { x: 50, y: 50 },
                                              y: value[0]
                                            }
                                          })}
                                        />
                                        <span className="text-[10px] w-6 text-right">{currentSlideData.backgroundImagePosition?.y ?? 50}%</span>
                                      </div>
                                    </div>
                                  </div>

                                  {/* Scale Control */}
                                  <div className="space-y-2">
                                    <div className="flex items-center justify-between">
                                      <Label className="text-xs flex items-center gap-2">
                                        <Maximize className="h-3 w-3" /> Scale
                                      </Label>
                                      <Button
                                        variant="ghost"
                                        size="sm"
                                        className="h-5 text-[10px] px-2"
                                        onClick={() => updateSlide(currentSlide, { backgroundImageScale: 100 })}
                                      >
                                        Reset
                                      </Button>
                                    </div>
                                    <div className="flex items-center gap-2">
                                      <Slider
                                        value={[currentSlideData.backgroundImageScale ?? 100]}
                                        min={100}
                                        max={300}
                                        step={5}
                                        className="flex-1"
                                        onValueChange={(value) => updateSlide(currentSlide, { backgroundImageScale: value[0] })}
                                      />
                                      <span className="text-[10px] w-8 text-right">{currentSlideData.backgroundImageScale ?? 100}%</span>
                                    </div>
                                  </div>

                                  {/* Rotation Control */}
                                  <div className="space-y-2">
                                    <div className="flex items-center justify-between">
                                      <Label className="text-xs flex items-center gap-2">
                                        <RotateCw className="h-3 w-3" /> Rotate
                                      </Label>
                                      <Button
                                        variant="ghost"
                                        size="sm"
                                        className="h-5 text-[10px] px-2"
                                        onClick={() => updateSlide(currentSlide, { backgroundImageRotation: 0 })}
                                      >
                                        Reset
                                      </Button>
                                    </div>
                                    <div className="flex items-center gap-2">
                                      <Slider
                                        value={[currentSlideData.backgroundImageRotation ?? 0]}
                                        min={0}
                                        max={360}
                                        step={5}
                                        className="flex-1"
                                        onValueChange={(value) => updateSlide(currentSlide, { backgroundImageRotation: value[0] })}
                                      />
                                      <span className="text-[10px] w-8 text-right">{currentSlideData.backgroundImageRotation ?? 0}Â°</span>
                                    </div>
                                  </div>
                                </div>
                              </>
                            ) : (
                              <div className="flex gap-2">
                                <Button
                                  variant="outline"
                                  size="sm"
                                  className="flex-1"
                                  onClick={() => generateBackgroundImage(currentSlide)}
                                  disabled={currentSlideData.isGeneratingImage || isUploadingImage}
                                >
                                  {currentSlideData.isGeneratingImage ? (
                                    <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                                  ) : (
                                    <Sparkles className="h-4 w-4 mr-2" />
                                  )}
                                  Generate
                                </Button>
                                <Button
                                  variant="outline"
                                  size="sm"
                                  className="flex-1"
                                  onClick={() => fileInputRef.current?.click()}
                                  disabled={currentSlideData.isGeneratingImage || isUploadingImage}
                                >
                                  {isUploadingImage ? (
                                    <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                                  ) : (
                                    <Upload className="h-4 w-4 mr-2" />
                                  )}
                                  Upload
                                </Button>
                              </div>
                            )}
                          </div>
                        </>
                      )}
                    </CardContent>
                  </Card>

                  {/* Layout Section */}
                  <Card className="shadow-sm">
                    <CardContent className="p-4 space-y-4">
                      <div className="flex items-center justify-between">
                        <Label htmlFor="layout-toggle" className="font-medium">Layout</Label>
                        <Switch
                          id="layout-toggle"
                          checked={layoutExpanded}
                          onCheckedChange={setLayoutExpanded}
                        />
                      </div>
                      {layoutExpanded && (
                        <>
                          <div className="flex items-center justify-end">
                            <Button variant="ghost" size="sm" onClick={shuffleAllLayouts}>
                              <Shuffle className="h-4 w-4 mr-2" />
                              Shuffle All
                            </Button>
                          </div>
                          <p className="text-xs text-muted-foreground">
                            {currentSlide === 0
                              ? "First slide - Diagonal Split recommended"
                              : currentSlide === slides.length - 1
                                ? "Last slide - Centered/Card best for CTAs"
                                : "Middle slide - Various layouts work well"}
                          </p>
                          <LayoutPicker currentLayout={currentLayout} onLayoutChange={handleSlideLayoutChange} theme={theme} />
                        </>
                      )}
                    </CardContent>
                  </Card>
                </TabsContent>

                <TabsContent value="brand" className="mt-0 space-y-4 m-0">
                  <Card className="shadow-sm">
                    <CardContent className="p-4 space-y-4">
                      <div className="flex items-center justify-between">
                        <h3 className="text-sm font-semibold text-primary">Brand Settings</h3>
                        <div className="flex items-center gap-2">
                          <Label htmlFor="branding-toggle" className="text-xs text-muted-foreground">Show Branding</Label>
                          <Switch
                            id="branding-toggle"
                            checked={showBranding}
                            onCheckedChange={setShowBranding}
                          />
                        </div>
                      </div>

                      {showBranding && (
                        <>
                          <div className="space-y-2">
                            <Label htmlFor="brandName">Name</Label>
                            <Input
                              id="brandName"
                              value={brandName}
                              onChange={(e) => setBrandName(e.target.value)}
                              placeholder="Your Name"
                            />
                          </div>

                          <div className="space-y-2">
                            <Label htmlFor="brandHandle">Handle / Website</Label>
                            <Input
                              id="brandHandle"
                              value={brandHandle}
                              onChange={(e) => setBrandHandle(e.target.value)}
                              placeholder="@YourHandle / www.YourWebsite.com"
                            />
                          </div>

                          <div className="space-y-3">
                            <div className="flex items-center justify-between">
                              <Label htmlFor="brandLogo-toggle" className="font-medium">Profile Image</Label>
                              <Switch
                                id="brandLogo-toggle"
                                checked={brandLogoEnabled}
                                onCheckedChange={setBrandLogoEnabled}
                              />
                            </div>
                            {brandLogoEnabled && (
                              <div className="flex items-center gap-3">
                                {brandImage ? (
                                  <div className="relative">
                                    <img
                                      src={brandImage}
                                      alt="Brand"
                                      className="w-12 h-12 rounded-full object-cover"
                                    />
                                    <Button
                                      variant="destructive"
                                      size="icon"
                                      className="absolute -top-1 -right-1 h-5 w-5"
                                      onClick={() => setBrandImage(null)}
                                    >
                                      <Trash2 className="h-3 w-3" />
                                    </Button>
                                  </div>
                                ) : (
                                  <div className="w-12 h-12 rounded-full bg-muted flex items-center justify-center">
                                    <User className="h-6 w-6 text-muted-foreground" />
                                  </div>
                                )}
                                <Input
                                  type="file"
                                  accept="image/*"
                                  className="flex-1"
                                  onChange={(e) => {
                                    const file = e.target.files?.[0]
                                    if (file) {
                                      const reader = new FileReader()
                                      reader.onloadend = () => {
                                        setBrandImage(reader.result as string)
                                      }
                                      reader.readAsDataURL(file)
                                    }
                                  }}
                                />
                              </div>
                            )}
                          </div>
                        </>
                      )}
                    </CardContent>
                  </Card>
                </TabsContent>
              </div>
            </div>
          </Tabs>
        </div>
      </div>

      {/* Collapse Button */}
      <button
        onClick={() => setSidebarCollapsed(!sidebarCollapsed)}
        className="absolute left-0 top-1/2 -translate-y-1/2 z-50 bg-background border rounded-r-lg p-2 shadow-md hover:bg-muted transition-all"
        style={{ left: sidebarCollapsed ? 0 : '360px' }}
      >
        {sidebarCollapsed ? (
          <PanelLeft className="h-4 w-4" />
        ) : (
          <PanelLeftClose className="h-4 w-4" />
        )}
      </button>

      {/* Main Content Area */}
      <div className="flex-1 flex flex-col h-full overflow-hidden min-w-0">
        {/* Top Toolbar */}
        <div className="sticky top-0 z-[60] bg-background border-b">
          <div className="px-6 py-3 flex items-center justify-between">
            <div className="flex items-center gap-4">
              <Button variant="ghost" size="sm" onClick={onBack}>
                <ArrowLeft className="h-4 w-4 mr-2" />
                Back
              </Button>
              <div>
                <h1 className="font-semibold">{initialData.topic}</h1>
                <p className="text-xs text-muted-foreground">{slides.length} slides</p>
              </div>
            </div>
            <div className="flex items-center gap-2">
              {/* Save status */}
              <div className="flex items-center gap-2 text-sm text-muted-foreground mr-2">
                {isSaving ? (
                  <>
                    <Cloud className="h-4 w-4 animate-pulse text-primary" />
                    <span className="hidden sm:inline">Saving...</span>
                  </>
                ) : lastSaved ? (
                  <>
                    <Check className="h-4 w-4 text-green-500" />
                    <span className="hidden sm:inline">Saved</span>
                  </>
                ) : null}
              </div>

              {/* Download dropdown */}
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="outline" size="icon" disabled={isDownloading} title="Download">
                    {isDownloading ? (
                      <Loader2 className="h-4 w-4 animate-spin" />
                    ) : (
                      <Download className="h-4 w-4" />
                    )}
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem onClick={downloadCurrentSlide}>
                    <FileImage className="h-4 w-4 mr-2" />
                    Download Slide
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={downloadAllSlides}>
                    <FolderArchive className="h-4 w-4 mr-2" />
                    Download All
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          </div>
        </div>

        <div className="flex-1 flex overflow-hidden">
          {/* Center Preview Area - Static */}
          <div className="flex-1 p-2 overflow-y-auto flex flex-col items-center justify-center bg-muted/30 relative custom-scrollbar">
            {isAdapting && (
              <div className="absolute inset-0 flex items-center justify-center bg-background/50 backdrop-blur-sm rounded-2xl z-10">
                <div className="flex flex-col items-center gap-2">
                  <Sparkles className="h-8 w-8 animate-pulse text-primary" />
                  <span className="text-sm font-medium">Adapting content for new layout...</span>
                </div>
              </div>
            )}

            <div ref={slidePreviewRef} className="flex-none shadow-2xl rounded-xl overflow-hidden ring-1 ring-border/50" style={{ width: '400px', height: '500px' }}>
              <SlidePreview
                slide={currentSlideData}
                theme={theme}
                layout={currentLayout}
                slideNumber={currentSlide + 1}
                totalSlides={slides.length}
                brandName={brandName}
                brandHandle={brandHandle}
                brandImage={brandLogoEnabled ? brandImage : null}
                showBrandImage={brandLogoEnabled}
                showBranding={showBranding}
                onBrandNameChange={setBrandName}
                onBrandHandleChange={setBrandHandle}
                onBrandImageChange={setBrandImage}
                onCustomTextMove={(textId, x, y) => {
                  updateSlide(currentSlide, {
                    customTexts: currentSlideData.customTexts?.map((t) =>
                      t.id === textId ? { ...t, x, y } : t
                    ),
                  })
                }}
                templateId={templateId || undefined}
              />
            </div>

            {/* Quick Navigation - Floating or Just below */}
            <div className="flex items-center gap-4 mt-2">
              <Button
                variant="outline"
                size="icon"
                className="h-8 w-8 rounded-full shadow-sm bg-background hover:bg-muted"
                onClick={() => goToSlide(currentSlide - 1)}
                disabled={currentSlide === 0}
              >
                <ChevronLeft className="h-4 w-4" />
              </Button>
              <span className="text-xs font-medium text-muted-foreground">
                {currentSlide + 1} / {slides.length}
              </span>
              <Button
                variant="outline"
                size="icon"
                className="h-8 w-8 rounded-full shadow-sm bg-background hover:bg-muted"
                onClick={() => goToSlide(currentSlide + 1)}
                disabled={currentSlide === slides.length - 1}
              >
                <ChevronRight className="h-4 w-4" />
              </Button>
            </div>
          </div>

          {/* Right Sidebar - Vertical Thumbnails */}
          <div className="w-72 bg-background border-l flex flex-col h-full shadow-sm z-20 min-h-0">
            <div className="p-4 border-b flex items-center justify-between bg-muted/20">
              <h3 className="font-semibold text-sm flex items-center gap-2">
                <Layout className="h-4 w-4 text-muted-foreground" />
                Slides
              </h3>
              <span className="text-xs text-muted-foreground bg-muted px-2 py-0.5 rounded-full">{slides.length}</span>
            </div>

            <div className="flex-1 overflow-y-auto bg-muted/10 min-h-0">
              <div className="p-3 space-y-3">
                {slides.map((slide, index) => (
                  <button
                    key={index}
                    onClick={() => goToSlide(index)}
                    className={`group relative w-full flex gap-3 p-3 rounded-xl text-left transition-all border ${index === currentSlide
                      ? "bg-background border-primary ring-1 ring-primary shadow-sm"
                      : "bg-background border-transparent hover:border-border hover:shadow-sm"
                      }`}
                  >
                    {/* Number Indicator */}
                    <div className={`flex h-6 w-6 shrink-0 items-center justify-center rounded-full text-[10px] font-bold transition-colors ${index === currentSlide
                      ? "bg-primary text-primary-foreground"
                      : "bg-muted text-muted-foreground group-hover:bg-muted-foreground/20"
                      }`}>
                      {index + 1}
                    </div>

                    <div className="flex-1 min-w-0">
                      <div className={`text-sm font-medium truncate mb-1 ${index === currentSlide ? "text-primary" : "text-foreground"}`}>
                        {slide.heading || "Untitled Slide"}
                      </div>
                      <div className="flex items-center gap-2 text-[10px] text-muted-foreground">
                        <span className="uppercase tracking-wider">{LAYOUT_OPTIONS.find((l) => l.id === slide.layout)?.name || "Centered"}</span>
                        {slide.backgroundImageUrl && (
                          <span className="flex items-center gap-1 text-green-600">
                            <ImageIcon className="h-3 w-3" /> Img
                          </span>
                        )}
                      </div>
                    </div>

                    {/* Active Indicator Bar */}
                    {index === currentSlide && (
                      <div className="absolute left-0 top-3 bottom-3 w-1 bg-primary rounded-r-full" />
                    )}
                  </button>
                ))}
              </div>
            </div>

            <div className="p-4 border-t bg-background space-y-2">
              <Button onClick={addSlide} className="w-full gap-2" size="sm">
                <Plus className="h-4 w-4" /> Add New Slide
              </Button>
              <Button
                variant="ghost"
                size="sm"
                onClick={deleteSlide}
                disabled={slides.length <= 1}
                className="w-full gap-2 text-muted-foreground hover:text-destructive hover:bg-destructive/10"
              >
                <Trash2 className="h-4 w-4" /> Delete Current
              </Button>
            </div>
          </div>
        </div>
      </div>
      {/* Hidden Export Container */}
      {isExporting && (
        <div style={{ position: 'fixed', left: '-9999px', top: 0, zIndex: -50, pointerEvents: 'none', opacity: 1 }}>
          {slides.map((slide, index) => (
            <div key={index} id={`slide-export-${index}`} style={{ width: '400px', height: '500px' }}>
              <SlidePreview
                slide={slide}
                theme={theme}
                layout={slide.layout || "centered"}
                slideNumber={index + 1}
                totalSlides={slides.length}
                brandName={brandName}
                brandHandle={brandHandle}
                brandImage={brandLogoEnabled ? brandImage : null}
                showBrandImage={brandLogoEnabled}
                showBranding={showBranding}
                onBrandNameChange={() => { }} // No-op for export
                onBrandHandleChange={() => { }}
                onBrandImageChange={() => { }}
                onCustomTextMove={() => { }}
                templateId={initialData.templateId || undefined}
              />
            </div>
          ))}
        </div>
      )}
    </div>
  )
}
